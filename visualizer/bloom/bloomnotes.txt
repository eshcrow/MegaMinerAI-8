1 - Ok we're going to go ahead and assume the server guys have done their job and we have a parser already for us.  The parser is responsible for taking a gamelog and putting it into a format that we, the visualizer, can read!  Unless you're debugging the parser, 99.9% of your time in the parser directory will be spent in structures.h.  Let's take a quick look.
 ====================  [ OPEN parser/structures.h ]  ========================= 

2 - At the top of the file, you're going to notice a bunch of constants.  These are IDs for animations that bloom will send to us.  We get sent a pointer to an animation 
 ====================  [ 51 gg ]  ========================= 
 which contains an integer which represents the type.  We use these constants to figure out which animation this is, and treat it appropriately.  
 * SIDEBAR on pointers real quick.  Pointers are variables that point to data.  Unlike int or char or string, a pointer will contain the address of one of those variables.  This is useful in this case because we can force one pointer to act like another.  
 ====================  [ 79 gg ]  =========================
 As you can see, these are our animations.  The "colon public Animation" indicates that each of these Animations inherit the base class, "Animation."  Because they all inherit this base, when we get a pointer to an animation, we can force it to pretend it is any one of these specific animations.  More on that later.  

3 - Now we're going to go back up to our "Plant" class. 
 ====================  [ 19 gg ]  =========================
 In this class we see all the information that competitors will see when they're managing their plants. 
  - ObjectID is a unique number to both teams for a plant or any other object.
  - x, y are the coordinates of the plant at that state. You'll notice that they're integers.  If our plants moved, which they don't, we'd probably want to make them floats so we could animate between discrete positions.
  - OwnerID represents which player owns this plant.  In our case, there are two players so this will always be a 0 or a 1. 
  - root, leaf, flower are booleans (although represented as ints) on whether or not a plant has one of these elements. 
  /* 
  - rootLevel, leafLevel, and flowerLevel represent what level each element is at.  In bloom you could "level up" different parts of your plants, so it may be useful to know what level each are at.
  - rootLevelUp, leafLevelUp, and flowerLevelUp are booleans again representing if we can level up this plant element on this turn.  
  - canAct is another boolean telling the player if they can do anything to the plant this turn. 
  */
For this tutorial, we're not going to worry about plant levels.  So we'll just concentrate on this section.

 ====================  [ 22 gg v 30 gg ]  =========================

4 - Ok so the next main area of this file you'll deal with is GameState
 
 ====================  [ 144 gg ]  =========================

GameState holds all the plants for a turn of a game. It also holds the dimensions of the board, how many resources each player has to spend, and who's turn it is.

 ====================  [ 113 gg ]  =========================

This is the vector which holds all the plants for this state.

 * SIDEBAR on vectors.  Vectors are like arrays, except they don't have a specific size.  They dynamically resize to accomodate whatever you want to put in them.  "vector<Plant>" tells the compiler that this vector is going to be holding elements of the type, Plant.

5 - Finally, we have a structure which holds all the turns of our game.

 ====================  [ 134 gg ]  =========================
 
 Once again, this is a vector which holds as many turns as are in this gamelog. "players" holds the names of the two people who are playing in this game.  Finally, winner, holds the id of the player who wins this game.

6 - Ok, that's it for structures at this point.  We are ready to build our project file.

 ====================  [ :q ]  =========================

7 - Feel free to look at piracy or this screencast to duplicate a lot of this code.  In the future we probably won't have as much boilerplate code (code required to interface two modules together), but for now we have to deal with this.

8 - The first thing we're going to have to make is the project file to tell our compiler what to do when building.  We'll just name it "bloom.pro"

 ====================  [ vim bloom.pro ]  =========================

    INCLUDEPATH += ../interfaces \  # INCLUDEPATH tells the compiler where to find our
      ../parser \                   # header files for this project.
      ../parser/sexp \              # interfaces is the code to join the plugin to the core
      ../common/                    # parser is self-explanatory. Common contains code common 
                                    # to the visualizer core and plugins
    DEPENDPATH += ../common/        # DEPENDPATH are the files that we want to check in addition
                                    # to those that we are writing now for changes to see
                                    # if we need to recompile
    win32:LIBS += ./parser/sexp/sexpXP.a
    else:LIBS += ./parser/sexp/sexp.a # This is just hooking bloom up to the parser
    TEMPLATE = lib      # Tells the compiler that this is a library and not a standalone program
    TARGET = bloom      # Tells the compiler that we're naming this plugin "bloom"
    SOURCES += *.cpp \  # What are the cpp files for this plugin
      ./parser/*.cpp
      
    HEADERS += bloom.h  # What are the header files for this plugin

    # These tell the compiler that we're going to compile and link with profiling 
    # and debugging symbols.  These help us out when the visualizer is going really slow
    # or something is going really wrong.
    QMAKE_CFLAGS_DEBUG += -pg    
    QMAKE_CXXFLAGS_DEBUG += -pg
    QMAKE_LFLAGS_DEBUG += -pg
    CONFIG += debug plugin    # Tells the compiler that this is going to be a debug build
                              # and a plugin

    debug:DEFINES += __DEBUG__ # This constant will be available when we're in a debug build.
    DESTDIR = ../plugins/     # Where to put the plugin on a successful build.

 ====================  [ :q ]  =========================

9 - Ok, you noticed that we linked bloom up to the parser.  We need to build the parser 
before we can do that properly.

 ====================  [ cd parser ]  =========================
 ====================  [ make ]  =========================
 ====================  [ cd sexp ]  =========================
 ====================  [ make ]  =========================
 ====================  [ cd ../.. ]  =========================

Now the parser is properly built and we can use it.  Ok time to start programming.

10 - The first file we're going to make is "bloom.h"

 This header file will contain the class declaration for the main plugin which will
 allow the core visualizer to properly find it.
 ====================  [ vim bloom.h ]  =========================
    #ifndef BLOOM_H
    #define BLOOM_H

    #include "parser/parser.h"      // We need this to talk to the parser
    #include "parser/structures.h"  // This as well for the structures we'll use
    #include "igame.h"              // This header file contains a base class
                                    // we'll use to make a common interface
                                    // between the core visualizer and bloom
    #include "animsequence.h"       // This holds AnimSequence which is a 
                                    // sort of timeline the visualizer uses.

    namespace visualizer            // For name safety (preventing the duplication of names)
    {                               // we're going to use this namespace.  Anything outside
                                    // of this namespace will not conflict with anything
                                    // inside of it.
       
      class Bloom: public AnimSequence, public visualizer::IGame
                   // We're calling our main class, 'Bloom'.
                   // "public AnimSequence" tells us that 'Bloom' will contain our timeline
                   // "public visualizer::IGame" is the common basis which helps the core
                   // find bloom.
      {
        Q_OBJECT;  // Needed
        Q_INTERFACES( visualizer::IGame ); 
            //  ^^ Tells the compiler that this is the main in the plugin
        public:
          Bloom();   // Constructor
          ~Bloom();  // Deconstructor

          // These three methods are required by IGame for this plugin to exist and link
          // to the core. We'll talk about them more in bloom.cpp
          LogRegex logFileInfo();                     
          void loadGamelog( std::string gamelog );
        private:
          Game *m_game;       // Variable which holds the turns.
      }; // Bloom

    } // visualizer

    #endif

 ====================  [ :q ]  =========================

11 - Now we can start working on the implementation file "bloom.cpp"

 ====================  [ vim bloom.cpp ]  =========================

    #include "bloom.h"

    namespace visualizer
    {
      Bloom::Bloom() // Constructor
      {
        m_game = 0;  // Don't setup the game yet.
      }

      Bloom::~Bloom() // Deconstructor
      {
        delete m_game; // Cleanup once we're done
      }

      LogRegex Bloom::logFileInfo() 
          // Function tells the visualizer core what gamelogs we can handle
      {
        LogRegex lr; // Structure which holds regex to determine gamelog 
        // ownership
        lr.regex = "Plant"; // We'll just assume this is a bloom gamelog
        lr.startSize = 500; // How many characters to read before giving up.

        return lr;
      }

      void Bloom::loadGamelog( std::string gamelog )
      {
        // We'll just use this to prove that it's loading bloom when it
        // should
        cout << "Load Bloom Gamelog"
        // Let's just make sure that we don't have memory leaks.
        delete m_game; 
        // Allocates the memory we need for the new gamelog
        m_game = new Game;

        // So this is really important.  This loads the gamelog into 
        // memory when we call it.
        if( !parseFile( *m_game, (char*)gamelog.c_str() ) ) // Not safe
        {
          // It didn't load correctly.  Cleanup everything
          delete m_game;
          // This is special macros for throwing exceptions.  
          // It's good to use exceptions whenever you can so we know
          // exactly when and where our code is failing.  It will
          // immediately exit and print the error
          THROW
            (
              GameException, "Cannot Load The Gamelog."
            );
        }
        
        // So, now the gamelog is loaded into memory.  We'll just check to
        // make sure everything is working alright.
        // Does anyone have any questions before I move on?

      }
    }
 
 ====================  [ :wq ]  =========================

